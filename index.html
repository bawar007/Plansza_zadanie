<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <title></title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      * {
        margin: 0;
        padding: 0;
      }
      body {
        font-family: Arial, sans-serif;
        text-align: center;
        margin: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      canvas {
        border: 2px solid #333;
        margin: 10px;
      }

      #picker {
        display: block;
        width: 500px;
        border: 2px solid #333;
        padding: 10px;
      }

      .sectionSelector {
        margin: 10px;
        font-size: 16px;
        padding: 5px;
      }
      .pickerWrapper {
        margin-top: 10px;
        max-width: 500px;
        max-height: 100px;
        overflow-y: auto;
      }
      .imgButton {
        width: 50px;
        height: 50px;
        margin: 5px;
        border: 2px solid rgb(51, 51, 51);
        padding: 0px;
        position: relative;
        background: rgb(255, 255, 255);
      }
      .imgButton img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      .lastItem {
        width: 500px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        padding: 10px;
        border: 2px solid black;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <canvas id="board" width="500" height="500"></canvas>

    <div id="picker"></div>
    <div class="lastItem">
      <h3>Ostatnio użyte krążki</h3>
      <canvas id="palette" width="500" height="70"></canvas>
    </div>
    <button id="clearBoard">Wyczyść planszę</button>

    <div id="message" style="color: red; height: 24px; margin: 10px"></div>
    <script>
      const board = document.getElementById("board");
      const palette = document.getElementById("palette");
      const ctxBoard = board.getContext("2d");
      const ctxPalette = palette.getContext("2d");

      const cellSize = ctxBoard.canvas.width / 9;
      const rows = 9;
      const cols = 9;

      let dragging = null;
      let draggingPieceIdx = null;
      let prevPiece = null;
      let paletteHistory = [];

      const loadedImages = {};
      const pieces = [];

      const sections = [
        {
          name: "Krążki obrazkowe sudoku",
          items: [
            { letter: "A", color: "red", img: "./assets/a.png" },
            { letter: "B", color: "red", img: "./assets/b.png" },
            { letter: "C", color: "red", img: "./assets/c.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
          ],
        },
        {
          name: "Krążki symbole do kodowania",
          items: [
            { letter: "A", color: "red", img: "./assets/a.png" },
            { letter: "B", color: "red", img: "./assets/b.png" },
            { letter: "C", color: "red", img: "./assets/c.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
          ],
        },
        {
          name: "Krążki kolorowa matematyka",
          items: [
            { letter: "A", color: "red", img: "./assets/a.png" },
            { letter: "B", color: "red", img: "./assets/b.png" },
            { letter: "C", color: "red", img: "./assets/c.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
          ],
        },
        {
          name: "Krążki materiał obrazkowy",
          items: [
            { letter: "A", color: "red", img: "./assets/a.png" },
            { letter: "B", color: "red", img: "./assets/b.png" },
            { letter: "C", color: "red", img: "./assets/c.png" },
            { letter: "D", color: "red", img: "./assets/d.png" },
          ],
        },
      ];
      const blockColors = [
        ["red", "lightblue", "orange"], //bloki 3x3 poziomy 1-3
        ["limegreen", "pink", "lightgray"], //bloki 3x3 poziomy 4-6
        ["yellow", "violet", "blue"], //bloki 3x3 poziomy 7-9
      ];

      function getImage(src, callback) {
        if (loadedImages[src]) {
          callback(loadedImages[src]);
        } else {
          const img = new Image();
          img.src = src;
          img.onload = () => {
            loadedImages[src] = img;
            callback(img);
          };
        }
      }

      function isOccupied(x, y) {
        return pieces.some(
          (p) => Math.abs(p.x - x) < 5 && Math.abs(p.y - y) < 5
        );
      }

      function showMessage(txt) {
        const msg = document.getElementById("message");
        msg.textContent = txt;
      }

      function drawBoard() {
        ctxBoard.clearRect(0, 0, board.width, board.height);

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            // znajdź indeks bloku 3x3
            const blockRow = Math.floor(r / 3);
            const blockCol = Math.floor(c / 3);
            const color = blockColors[blockRow][blockCol];

            const x = c * cellSize + cellSize / 2;
            const y = r * cellSize + cellSize / 2;

            ctxBoard.beginPath();
            const size = cellSize * 0.8;
            ctxBoard.rect(x - size / 2, y - size / 2, size, size); //lub ctxBoard.arc(x, y, cellSize / 2 - 8, 0, Math.PI * 2)
            ctxBoard.fillStyle = color;
            ctxBoard.fill();
            ctxBoard.strokeStyle = color;
            ctxBoard.stroke();
          }
        }

        // rysuj krążki z tablicy pieces
        for (let p of pieces) {
          if (p.img) {
            const size = cellSize * 0.6;
            const left = p.x - size / 2;
            const top = p.y - size / 2;
            getImage(p.img, (img) => {
              ctxBoard.drawImage(
                img,
                p.x - cellSize * 0.3,
                p.y - cellSize * 0.3,
                cellSize * 0.6,
                cellSize * 0.6
              );
              ctxBoard.save();
              ctxBoard.strokeStyle = "#333";
              ctxBoard.lineWidth = 1;
              ctxBoard.strokeRect(left, top, size, size);
              ctxBoard.restore();
            });
          } else {
            // Placeholder jeśli brak obrazka
            ctxBoard.beginPath();
            ctxBoard.arc(p.x, p.y, cellSize * 0.4, 0, Math.PI * 2);
            ctxBoard.fillStyle = p.color;
            ctxBoard.fill();
            ctxBoard.strokeStyle = "#333";
            ctxBoard.stroke();
            if (p.letter) {
              ctxBoard.fillStyle = "#fff";
              ctxBoard.font = "bold 22px Arial";
              ctxBoard.textAlign = "center";
              ctxBoard.textBaseline = "middle";
              ctxBoard.fillText(p.letter, p.x, p.y);
            }
          }
        }
      }

      drawBoard();

      function drawPicker() {
        const picker = document.getElementById("picker");
        picker.innerHTML = "";

        // Tworzenie selecta do wyboru sekcji
        const sectionSelect = document.createElement("select");
        sectionSelect.className = "sectionSelector";

        sections.forEach((section, secIdx) => {
          const option = document.createElement("option");
          option.value = secIdx;
          option.textContent = section.name;
          sectionSelect.appendChild(option);
        });
        picker.appendChild(sectionSelect);

        // Kontener na obrazki
        const imagesDiv = document.createElement("div");
        imagesDiv.className = "pickerWrapper";
        picker.appendChild(imagesDiv);

        // Funkcja do wyświetlania obrazków z wybranej sekcji
        function showImages(secIdx) {
          imagesDiv.innerHTML = "";
          sections[secIdx].items.forEach((item) => {
            const imgBtn = document.createElement("button");
            imgBtn.className = "imgButton";
            imgBtn.title = item.letter;

            const img = document.createElement("img");
            img.src = item.img;
            imgBtn.appendChild(img);

            imgBtn.onclick = () => pickFromList(item);

            imagesDiv.appendChild(imgBtn);
          });
        }

        // Obsługa zmiany sekcji
        sectionSelect.onchange = function () {
          showImages(this.value);
        };

        // Inicjalizacja – pokaż obrazki z pierwszej sekcji
        showImages(0);
      }

      drawPicker();

      function pickFromList(item) {
        // Dodaj do palety jeśli nie ma już takiego krążka
        if (
          !paletteHistory.some(
            (p) => p.letter === item.letter && p.color === item.color
          )
        ) {
          paletteHistory.unshift(item);
          if (paletteHistory.length > 10) paletteHistory.pop();
          drawPalette();
        }

        dragging = {
          color: item.color,
          letter: item.letter,
          img: item.img,
          x: 0,
          y: 0,
        };
        draggingPieceIdx = null;
      }

      function drawPalette() {
        ctxPalette.clearRect(0, 0, palette.width, palette.height);
        paletteHistory.forEach((item, i) => {
          const x = 40 + i * 45;
          const y = 35;
          if (item.img) {
            getImage(item.img, (img) => {
              ctxPalette.drawImage(img, x - 20, y - 20, 40, 40);
              ctxPalette.save();
              ctxPalette.strokeStyle = "#333";
              ctxPalette.lineWidth = 2;
              ctxPalette.strokeRect(x - 20, y - 20, 40, 40);
              ctxPalette.restore();
            });
          }
        });
      }

      drawPalette();

      palette.addEventListener("mousedown", (e) => {
        const rect = palette.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        paletteHistory.forEach((item, i) => {
          const x = 40 + i * 45;
          const y = 35;
          const dx = mx - x;
          const dy = my - y;
          if (dx * dx + dy * dy < 20 * 20) {
            dragging = {
              color: item.color,
              letter: item.letter,
              img: item.img,
              x: mx,
              y: my,
            };
            draggingPieceIdx = null;
          }
        });
      });

      board.addEventListener("mousemove", (e) => {
        if (dragging) {
          const rect = board.getBoundingClientRect();
          dragging.x = e.clientX - rect.left;
          dragging.y = e.clientY - rect.top;
          drawBoard();

          if (dragging.img) {
            getImage(dragging.img, (img) => {
              ctxBoard.drawImage(
                img,
                dragging.x - cellSize * 0.4,
                dragging.y - cellSize * 0.4,
                cellSize * 0.8,
                cellSize * 0.8
              );
            });
          }

          const c = Math.floor(dragging.x / cellSize);
          const r = Math.floor(dragging.y / cellSize);

          if (
            dragging.x < 2 ||
            dragging.x > board.width ||
            dragging.y < 2 ||
            dragging.y > board.height
          ) {
            showMessage("poza mapa");
            board.style.cursor = "default";
          } else {
            if (r >= 0 && r < rows && c >= 0 && c < cols) {
              const x = c * cellSize + cellSize / 2;
              const y = r * cellSize + cellSize / 2;
              if (isOccupied(x, y)) {
                showMessage("nie można postawić");
                board.style.cursor = "not-allowed";
              } else {
                showMessage("");
                board.style.cursor = "default";
              }
            }
          }
        }
      });

      board.addEventListener("mouseleave", () => {
        if (dragging) {
          // Jeśli przeciągany był krążek z planszy, wróć go na miejsce
          if (prevPiece) {
            pieces.push(prevPiece);
            drawBoard();
          }
          dragging = null;
          draggingPieceIdx = null;
          prevPiece = null;
          showMessage("");
          drawBoard();
        }
      });

      board.addEventListener("mouseup", (e) => {
        if (dragging) {
          const rect = board.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;

          // znajdź najbliższe pole
          const c = Math.floor(mx / cellSize);
          const r = Math.floor(my / cellSize);

          if (r >= 0 && r < rows && c >= 0 && c < cols) {
            const x = c * cellSize + cellSize / 2;
            const y = r * cellSize + cellSize / 2;
            if (!isOccupied(x, y)) {
              pieces.push({
                x,
                y,
                color: dragging.color,
                letter: dragging.letter,
                img: dragging.img,
              });
              dragging = null;
              draggingPieceIdx = null;
              prevPiece = null;
              showMessage("");
              drawBoard();
            } else {
              showMessage("nie można postawić");
              return;
            }
          }
        }
      });

      board.addEventListener("mousedown", (e) => {
        if (dragging) return;

        const rect = board.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // znajdź najbliższe pole
        const c = Math.floor(mx / cellSize);
        const r = Math.floor(my / cellSize);

        // współrzędne środka pola
        const x = c * cellSize + cellSize / 2;
        const y = r * cellSize + cellSize / 2;

        // sprawdź, czy kliknięto krążek na planszy
        const idx = pieces.findIndex(
          (p) => Math.abs(p.x - x) < 5 && Math.abs(p.y - y) < 5
        );
        if (idx !== -1) {
          dragging = {
            color: pieces[idx].color,
            letter: pieces[idx].letter,
            img: pieces[idx].img,
            x: mx,
            y: my,
          };
          draggingPieceIdx = idx;
          prevPiece = { ...pieces[idx] };
          pieces.splice(idx, 1); // usuń krążek z planszy na czas przeciągania
          drawBoard();
        }
      });

      board.addEventListener("contextmenu", (e) => {
        e.preventDefault(); // zapobiega domyślnemu menu kontekstowemu
        const rect = board.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // znajdź najbliższe pole
        const c = Math.floor(mx / cellSize);
        const r = Math.floor(my / cellSize);

        // współrzędne środka pola
        const x = c * cellSize + cellSize / 2;
        const y = r * cellSize + cellSize / 2;

        // znajdź krążek na tym polu (z tolerancją)
        const idx = pieces.findIndex(
          (p) => Math.abs(p.x - x) < 5 && Math.abs(p.y - y) < 5
        );
        if (idx !== -1) {
          pieces.splice(idx, 1); // usuń krążek
          drawBoard();
        }
      });

      document.getElementById("clearBoard").addEventListener("click", () => {
        pieces.length = 0;
        drawBoard();
      });
    </script>
  </body>
</html>
